name: iOS App Store Upload v3

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment name for environment-scoped secrets"
        required: false
        default: "prod"

jobs:
  release:
    name: Build, Sign and Upload to App Store Connect
    runs-on: macos-latest
    environment:
      name: ${{ inputs.environment }}
    env:
      BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
      P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
      IOS_TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      PROJECT_PATH: Run-C.xcodeproj
      SCHEME_NAME: Run-C
      APP_NAME_FALLBACK: Run-C
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
      APP_STORE_CONNECT_USERNAME: ${{ secrets.APP_STORE_CONNECT_USERNAME }}
      APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Show Xcode version
      run: xcodebuild -version

    - name: Compute unique build number
      run: |
        NEW_BUILD=$(date +%Y%m%d%H%M)
        echo "NEW_BUILD=$NEW_BUILD" >> $GITHUB_ENV
        echo "::notice title=Build Number::CFBundleVersion will be $NEW_BUILD"

    - name: Preflight - Check required secrets presence
      run: |
        check() { if [ -z "$1" ]; then echo "::warning title=Missing secret::${2} not set"; else echo "${2}: present"; fi }
        echo "Environment: ${{ inputs.environment }}"
        check "${BUILD_CERTIFICATE_BASE64}" "BUILD_CERTIFICATE_BASE64"
        check "${P12_PASSWORD}" "P12_PASSWORD"
        if [ -z "${KEYCHAIN_PASSWORD}" ]; then
          echo "::notice title=KEYCHAIN_PASSWORD::Secret not set; workflow will generate a temporary password"
        else
          echo "KEYCHAIN_PASSWORD: present"
        fi
        check "${PROVISIONING_PROFILE_BASE64}" "PROVISIONING_PROFILE_BASE64"
        if [ -n "${APP_STORE_CONNECT_API_KEY_ID}" ] && [ -n "${APP_STORE_CONNECT_ISSUER_ID}" ] && [ -n "${APP_STORE_CONNECT_API_PRIVATE_KEY}" ]; then
          echo "App Store Connect API secrets: present (will upload to TestFlight via API key)"
        elif [ -n "${APP_STORE_CONNECT_USERNAME}" ] && [ -n "${APP_SPECIFIC_PASSWORD}" ]; then
          echo "Apple ID upload secrets present (will upload to TestFlight via Apple ID)"
        else
          echo "::notice title=TestFlight upload::No upload credentials set; will skip App Store Connect upload and only produce IPA artifact"
        fi
      env:
        BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
        P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
        APP_STORE_CONNECT_USERNAME: ${{ secrets.APP_STORE_CONNECT_USERNAME }}
        APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}

    - name: Ensure keychain password
      run: |
        if [ -z "${KEYCHAIN_PASSWORD:-}" ]; then
          KEYCHAIN_PASSWORD=$(uuidgen | tr -d '-')
          echo "::notice title=Keychain password::KEYCHAIN_PASSWORD secret missing; using ephemeral value for this run"
        else
          echo "KEYCHAIN_PASSWORD provided via secrets."
        fi
        echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

    - name: Install Apple Certificate
      run: |
        if [ -z "$BUILD_CERTIFICATE_BASE64" ]; then echo "BUILD_CERTIFICATE_BASE64 not set"; exit 1; fi
        CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
        security list-keychain -d user -s $KEYCHAIN_PATH
        echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

    - name: Install Provisioning Profile
      run: |
        if [ -z "$PROVISIONING_PROFILE_BASE64" ]; then echo "PROVISIONING_PROFILE_BASE64 not set"; exit 1; fi
        PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision
        echo -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode -o $PP_PATH
        mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
        cp $PP_PATH ~/Library/MobileDevice/Provisioning\ Profiles
        echo "PP_PATH=$PP_PATH" >> $GITHUB_ENV
        # Extract profile metadata
        security cms -D -i $PP_PATH > $RUNNER_TEMP/profile.plist
        PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' $RUNNER_TEMP/profile.plist)
        PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' $RUNNER_TEMP/profile.plist)
        PROFILE_APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' $RUNNER_TEMP/profile.plist)
        PROFILE_TEAM_ID=${PROFILE_APP_ID%%.*}
        PROFILE_BUNDLE_ID=${PROFILE_APP_ID#*.}
        echo "Using Provisioning Profile: $PP_NAME ($PP_UUID)"
        echo "Profile TeamID: $PROFILE_TEAM_ID"
        echo "Profile BundleID: $PROFILE_BUNDLE_ID"
        echo "PP_UUID=$PP_UUID" >> $GITHUB_ENV
        echo "PP_NAME=$PP_NAME" >> $GITHUB_ENV
        echo "BUNDLE_ID=$PROFILE_BUNDLE_ID" >> $GITHUB_ENV
        if [ -z "${IOS_TEAM_ID:-}" ]; then
          echo "::notice title=Team ID::IOS_TEAM_ID not set; using $PROFILE_TEAM_ID from profile"
          echo "IOS_TEAM_ID=$PROFILE_TEAM_ID" >> $GITHUB_ENV
        fi

    - name: Detect signing certificate type
      run: |
        KEYCHAIN_PATH=${KEYCHAIN_PATH:-$RUNNER_TEMP/app-signing.keychain-db}
        FOUND=$(security find-identity -p codesigning -v "$KEYCHAIN_PATH" | sed 's/.*"\(.*\)"/\1/' || true)
        echo "::group::Available signing identities"
        echo "$FOUND"
        echo "::endgroup::"
        if echo "$FOUND" | grep -q "Apple Distribution"; then
          TYPE="Apple Distribution"
        elif echo "$FOUND" | grep -qE "iPhone Distribution|iOS Distribution"; then
          TYPE="Apple Distribution"
        else
          TYPE="Apple Distribution"
        fi
        echo "Using signingCertificate: $TYPE"
        echo "SIGNING_CERT=$TYPE" >> $GITHUB_ENV

    - name: Build and Archive (Release - signed)
      run: |
        set -euo pipefail
        ARCHIVE_PATH="${ARCHIVE_PATH:-$RUNNER_TEMP/Run-C-Release.xcarchive}"
        PROFILE_SPECIFIER="${PP_NAME:-$PP_UUID}"
        echo "Project: $PROJECT_PATH"
        echo "Scheme:  $SCHEME_NAME"
        echo "TeamID:  ${IOS_TEAM_ID}"
        echo "Bundle:  ${BUNDLE_ID}"
        echo "Profile: ${PROFILE_SPECIFIER}"
        xcodebuild archive \
          -project "$PROJECT_PATH" \
          -scheme "$SCHEME_NAME" \
          -configuration Release \
          -destination 'generic/platform=iOS' \
          -archivePath "$ARCHIVE_PATH" \
          CODE_SIGN_STYLE=Manual \
          CODE_SIGN_IDENTITY="Apple Distribution" \
          PROVISIONING_PROFILE_SPECIFIER="$PROFILE_SPECIFIER" \
          DEVELOPMENT_TEAM="${IOS_TEAM_ID}" \
          PRODUCT_BUNDLE_IDENTIFIER="${BUNDLE_ID}" \
          CURRENT_PROJECT_VERSION=$NEW_BUILD
        echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> $GITHUB_ENV

    - name: Extract App Metadata (version/build/bundle)
      run: |
        ARCHIVE_PATH="${ARCHIVE_PATH:-$RUNNER_TEMP/Run-C-Release.xcarchive}"
        APP_PATH=$(find "$ARCHIVE_PATH/Products/Applications" -maxdepth 1 -type d -name "*.app" -print -quit)
        if [ -z "$APP_PATH" ]; then echo "::error title=App bundle not found::No .app inside $ARCHIVE_PATH"; exit 1; fi
        PLIST="$APP_PATH/Info.plist"
        if [ ! -f "$PLIST" ]; then echo "::error title=Info.plist not found::$PLIST"; exit 1; fi
        APP_VERSION=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$PLIST")
        APP_BUILD=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$PLIST")
        BUNDLE_ID=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' "$PLIST")
        APP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :CFBundleDisplayName' "$PLIST" 2>/dev/null || /usr/libexec/PlistBuddy -c 'Print :CFBundleName' "$PLIST" 2>/dev/null || echo "$APP_NAME_FALLBACK")
        # sanitize for artifact name
        SAFE_APP_NAME=$(echo "${APP_NAME:-$APP_NAME_FALLBACK}" | tr ' ' '-' | tr -cd '[:alnum:]-')
        ARTIFACT_NAME="${SAFE_APP_NAME}-Release-IPA"
        echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
        echo "APP_BUILD=$APP_BUILD" >> $GITHUB_ENV
        echo "BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
        echo "::notice title=Build Metadata::BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Generate Export Options (manual with profile UUID)
      env:
        TEAM_ID: ${{ secrets.IOS_TEAM_ID }}
      run: |
        TEAM_ID=${TEAM_ID}
        PROFILE_VALUE="${PP_NAME:-$PP_UUID}"
        cat > $RUNNER_TEMP/export-options.plist <<EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>app-store-connect</string>
            <key>signingStyle</key>
            <string>manual</string>
            <key>teamID</key>
            <string>${TEAM_ID}</string>
            <key>signingCertificate</key>
            <string>${SIGNING_CERT}</string>
            <key>provisioningProfiles</key>
            <dict>
                <key>${BUNDLE_ID}</key>
                <string>${PROFILE_VALUE}</string>
            </dict>
            <key>stripSwiftSymbols</key>
            <true/>
            <key>uploadSymbols</key>
            <true/>
        </dict>
        </plist>
        EOF

    - name: Export Signed IPA
      run: |
        set -euo pipefail
        ARCHIVE_PATH="${ARCHIVE_PATH:-$RUNNER_TEMP/Run-C-Release.xcarchive}"
        EXPORT_DIR="${EXPORT_DIR:-$RUNNER_TEMP/export-release}"
        rm -rf "$EXPORT_DIR"
        xcodebuild -exportArchive \
          -archivePath "$ARCHIVE_PATH" \
          -exportPath "$EXPORT_DIR" \
          -exportOptionsPlist $RUNNER_TEMP/export-options.plist
        IPA_PATH=$(ls "$EXPORT_DIR"/*.ipa | head -n 1)
        if [ -z "$IPA_PATH" ]; then echo "::error title=Export failed::No IPA produced"; exit 1; fi
        echo "IPA_PATH=$IPA_PATH" >> $GITHUB_ENV
        echo "::notice title=Export Complete::IPA=$(basename "$IPA_PATH") BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Upload Signed IPA as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: ${{ env.EXPORT_DIR || format('{0}/export-release', runner.temp) }}/*.ipa
        retention-days: 90

    - name: Prepare App Store Connect API key (optional)
      if: ${{ env.APP_STORE_CONNECT_API_KEY_ID != '' && env.APP_STORE_CONNECT_ISSUER_ID != '' && env.APP_STORE_CONNECT_API_PRIVATE_KEY != '' }}
      env:
        APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        APP_STORE_CONNECT_API_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_API_PRIVATE_KEY }}
      run: |
        mkdir -p ~/.appstoreconnect/private_keys
        echo "$APP_STORE_CONNECT_API_PRIVATE_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8
        chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

    - name: Upload to App Store Connect (TestFlight)
      if: ${{ env.APP_STORE_CONNECT_API_KEY_ID != '' && env.APP_STORE_CONNECT_ISSUER_ID != '' && env.APP_STORE_CONNECT_API_PRIVATE_KEY != '' }}
      env:
        API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      run: |
        IPA_PATH=$(ls ${{ runner.temp }}/export-release/*.ipa | head -n 1)
        if [ -z "$IPA_PATH" ]; then echo "No IPA found"; exit 1; fi
        # Upload via altool (API key)
        echo "::group::Uploading to App Store Connect via API key (altool)"
        xcrun altool --upload-app -f "$IPA_PATH" -t ios --apiKey "$API_KEY_ID" --apiIssuer "$ISSUER_ID" --verbose
        EXITCODE=$?
        echo "::endgroup::"
        if [ $EXITCODE -ne 0 ]; then echo "::error title=Upload failed::altool exit $EXITCODE"; exit $EXITCODE; fi
        echo "::notice title=Upload Succeeded::Uploaded BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Upload to App Store Connect (Apple ID fallback)
      if: ${{ (env.APP_STORE_CONNECT_API_KEY_ID == '' || env.APP_STORE_CONNECT_ISSUER_ID == '' || env.APP_STORE_CONNECT_API_PRIVATE_KEY == '') && env.APP_STORE_CONNECT_USERNAME != '' && env.APP_SPECIFIC_PASSWORD != '' }}
      env:
        ASC_USERNAME: ${{ env.APP_STORE_CONNECT_USERNAME }}
        ASC_PASSWORD: ${{ env.APP_SPECIFIC_PASSWORD }}
      run: |
        IPA_PATH=$(ls ${{ runner.temp }}/export-release/*.ipa | head -n 1)
        if [ -z "$IPA_PATH" ]; then echo "No IPA found"; exit 1; fi
        # Upload via altool (Apple ID)
        echo "::group::Uploading to App Store Connect via Apple ID (altool)"
        xcrun altool --upload-app -f "$IPA_PATH" -t ios -u "$ASC_USERNAME" -p "$ASC_PASSWORD" --verbose
        EXITCODE=$?
        echo "::endgroup::"
        if [ $EXITCODE -ne 0 ]; then echo "::error title=Upload failed::altool exit $EXITCODE"; exit $EXITCODE; fi
        echo "::notice title=Upload Succeeded::Uploaded BundleID=$BUNDLE_ID Version=$APP_VERSION Build=$APP_BUILD"

    - name: Clean up keychain
      if: always()
      run: |
        security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
